{"source_code": "pragma solidity ^0.8.19;\n\ncontract ReentrancyVulnerable {\n    mapping(address => uint256) public balances;\n    \n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n    \n    function withdraw() public {\n        uint256 amount = balances[msg.sender];\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n        balances[msg.sender] = 0;\n    }\n}", "vulnerabilities": ["Reentrancy vulnerability - state update after external call", "No withdrawal amount validation"], "risk_score": 85, "summary": "Classic reentrancy vulnerability. State is updated after external call, allowing recursive attacks."}

{"source_code": "pragma solidity ^0.8.19;\n\ncontract IntegerOverflow {\n    mapping(address => uint256) public balances;\n    \n    function transfer(address to, uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        balances[to] += amount; // Potential overflow if balances[to] + amount > type(uint256).max\n    }\n}", "vulnerabilities": ["Potential integer overflow in balance update", "No SafeMath or built-in overflow protection"], "risk_score": 70, "summary": "Integer overflow vulnerability. Uses unchecked arithmetic operations that can overflow."}